package edu.harvard.iq.datatags.parser.decisiongraph;

import edu.harvard.iq.datatags.model.graphs.DecisionGraph;
import edu.harvard.iq.datatags.model.graphs.nodes.AskNode;
import edu.harvard.iq.datatags.model.graphs.nodes.CallNode;
import edu.harvard.iq.datatags.model.graphs.nodes.EndNode;
import edu.harvard.iq.datatags.model.graphs.nodes.Node;
import edu.harvard.iq.datatags.model.graphs.nodes.RejectNode;
import edu.harvard.iq.datatags.model.graphs.nodes.SetNode;
import edu.harvard.iq.datatags.model.graphs.nodes.TodoNode;
import edu.harvard.iq.datatags.model.types.AggregateType;
import edu.harvard.iq.datatags.model.types.AtomicType;
import edu.harvard.iq.datatags.model.types.CompoundType;
import edu.harvard.iq.datatags.model.types.TagType;
import edu.harvard.iq.datatags.model.types.ToDoType;
import edu.harvard.iq.datatags.model.values.AggregateValue;
import edu.harvard.iq.datatags.model.values.Answer;
import edu.harvard.iq.datatags.model.values.AtomicValue;
import edu.harvard.iq.datatags.model.values.CompoundValue;
import edu.harvard.iq.datatags.parser.decisiongraph.ast.AstAskNode;
import edu.harvard.iq.datatags.parser.decisiongraph.ast.AstCallNode;
import edu.harvard.iq.datatags.parser.decisiongraph.ast.AstEndNode;
import edu.harvard.iq.datatags.parser.decisiongraph.ast.AstNode;
import edu.harvard.iq.datatags.parser.decisiongraph.ast.AstRejectNode;
import edu.harvard.iq.datatags.parser.decisiongraph.ast.AstSetNode;
import edu.harvard.iq.datatags.parser.decisiongraph.ast.AstTodoNode;
import edu.harvard.iq.datatags.parser.exceptions.BadSetInstructionException;
import edu.harvard.iq.datatags.parser.exceptions.DataTagsParseException;
import static edu.harvard.iq.datatags.util.CollectionHelper.C;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * The result of parsing a decision graph code. Can create an actual decision
 * graph, when provided with a tag space (i.e a @{link CompoundType} instance).
 *
 * @author michael
 */
public class DecisionGraphParseResult {

    private int nextNodeId = 1;

    private final List<? extends AstNode> astNodes;

    final Map<List<String>, TagType> typesBySlot = new HashMap<>();
    final Map<TagType, List<String>> fullyQualifiedName = new HashMap<>();

    private CompoundType topLevelType;
    
    private DecisionGraph product;

    public DecisionGraphParseResult(List<? extends AstNode> someAstNodes) {
        astNodes = someAstNodes;
    }

    /**
     * Creates a ready-to-run {@link DecisionGraph} from the parsed nodes and the tagspace.
     * @param tagSpace The tag space used in the graph.
     * @return A ready-to-run graph.
     * @throws DataTagsParseException 
     */
    public DecisionGraph compile(CompoundType tagSpace) throws DataTagsParseException {
        buildTypeIndex(tagSpace);
        product = new DecisionGraph();

        // stage 1: Break nodes to componsnets, and
        // stage 2: Compile and link direct nodes.
        EndNode endAll = new EndNode(null);
        try {
            breakAstNodeList(astNodes).forEach((segment) -> buildNodes(segment, endAll) );
        } catch ( RuntimeException re ) {
            Throwable cause = re.getCause();
            if ((cause != null) && (cause instanceof DataTagsParseException)) {
                DataTagsParseException pe = (DataTagsParseException) cause;
                if ( pe.getOffendingNode() == null ) {
                    pe.setOffendingNode( C.head(astNodes) );
                }
                throw pe;
            } else {
                throw re;
            }
        }
        
        product.setStart( product.getNode(C.head(astNodes).getId()) );
        // TODO Graph-level validators go here.
        
        return product;
    }

    /**
     * Break a list of {@link AstNode}s to list of semantically connected nodes.
     * The list generated by the AST parser contains connections that do not
     * make semantic sense - such as a terminating node's next pointer. We break
     * the list on those. This is needed only on the top-level list of nodes -
     * the recursion will take care to connect the nodes that syntactically come after
     * terminating nodes in the answer sub-charts.
     *
     * @param parsed
     * @return
     */
    List<List<AstNode>> breakAstNodeList(List<? extends AstNode> parsed) {
        List<List<AstNode>> res = new LinkedList<>();
        List<AstNode> cur = new LinkedList<>();
        AstNode.Visitor<Boolean> chainBreaker = new AstNode.Visitor<Boolean>() {
            @Override
            public Boolean visit(AstAskNode astNode) { return false; }

            @Override
            public Boolean visit(AstCallNode astNode) { return false; }

            @Override
            public Boolean visit(AstEndNode astNode) { return true; }

            @Override
            public Boolean visit(AstSetNode astNode) { return false; }

            @Override
            public Boolean visit(AstRejectNode astNode) { return true; }

            @Override
            public Boolean visit(AstTodoNode astNode) { return false; }
        };
        
        for (AstNode node : parsed) {
            cur.add(node);
            if ( node.accept(chainBreaker) ) {
                res.add(cur);
                cur = new LinkedList<>();
            }
        }
        res.add(cur);

        return res;
    }

   
    /**
     * Compiles the list of nodes to an executable node structure. Note that the
     * node list has to make semantic sense - any nodes that follow a
     * terminating node (in the top-level list) will be ignored.
     *
     * @param astNodes The list of AST nodes to compile.
     * @param defaultNode The node to go to when a list of nodes does not end
     * with a terminating node.
     * @return The starting node for the execution..
     * @throws RuntimeException on errors in the code.
     */
    private Node buildNodes(List<? extends AstNode> astNodes, Node defaultNode)  {

        try {
            return astNodes.isEmpty()
                    ? defaultNode
                    : C.head(astNodes).accept(new AstNode.Visitor<Node>() {
                @Override
                public Node visit(AstAskNode astNode) {
                    AskNode res = new AskNode(astNode.getId());
                    res.setText(astNode.getTextNode().getText());
                    astNode.getTerms().forEach(t -> res.addTerm(t.getTerm(), t.getExplanation()));
                    
                    Node syntacticallyNext = buildNodes(C.tail(astNodes), defaultNode );
                    
                    astNode.getAnswers().forEach( ansSubNode -> res.setNodeFor(new Answer(ansSubNode.getAnswerText()), 
                                                                                buildNodes(ansSubNode.getSubGraph(), syntacticallyNext) ) );
                    
                    impliedAnswers(res).forEach( ans -> res.setNodeFor(ans, syntacticallyNext) ); 

                    return product.add( res );
                }

                @Override
                public Node visit(AstCallNode astNode) {
                    CallNode callNode = new CallNode(getCreateId(astNode));
                    callNode.setNextNode( buildNodes(C.tail(astNodes), defaultNode) );
                    return product.add(callNode);
                }

                @Override
                public Node visit(AstEndNode astNode) {
                    return product.add( new EndNode(getCreateId(astNode)) );
                }

                @Override
                public Node visit(AstSetNode astNode) {
                    final CompoundValue topValue = topLevelType.createInstance();
                    SetNodeValueBuilder valueBuilder = new SetNodeValueBuilder(topValue);
                    try {
                        astNode.getAssignments().forEach(asnmnt -> asnmnt.accept(valueBuilder));
                    } catch (RuntimeException re) {
                        throw new RuntimeException(new BadSetInstructionException(re.getMessage() + " (at node " + astNode + ")", astNode));
                    }

                    return product.add( new SetNode(astNode.getId(), topValue) );
                }

                @Override
                public Node visit(AstRejectNode astNode) {
                    return product.add(new RejectNode(getCreateId(astNode), astNode.getReason()));
                }

                @Override
                public Node visit(AstTodoNode astNode) {
                    return product.add( new TodoNode(getCreateId(astNode), astNode.getTodoText()) );
                }
            });

        } catch (RuntimeException re) {
            Throwable cause = re.getCause();
            if ((cause != null) && (cause instanceof DataTagsParseException)) {
                DataTagsParseException pe = (DataTagsParseException) cause;
                if ( pe.getOffendingNode() == null ) {
                    pe.setOffendingNode( C.head(astNodes) );
                }
                throw new RuntimeException( re.getMessage() + " (in node " + C.head(astNodes) + ")", pe );
            } else {
                throw re;
            }
        }
    }

    public List<? extends AstNode> getNodes() {
        return astNodes;
    }

    /**
     * Registers all the types and their possible slot names. That is, if we
     * have:
     *
     * <code><pre>
     *  top/mid/a
     *  top/mid/b
     *  top/mid2/b
     * </pre></code>
     *
     * We end up with:
     * <pre>
     *  top/mid/a  => top/mid/a
     *  mid/a      => top/mid/a
     *  a          => top/mid/a
     *  top/mid/b  => top/mid/b
     *  mid/b      => top/mid/b
     *  top/mid2/b => top/mid2/b
     *  mid2/b     => top/mid2/b
     * </pre>
     *
     * @param topLevel the top level type to build from.
     */
    void buildTypeIndex(CompoundType topLevel) {
        topLevelType = topLevel;

        // initial index
        topLevelType.accept(new TagType.VoidVisitor() {
            LinkedList<String> stack = new LinkedList<>();

            @Override
            public void visitAtomicTypeImpl(AtomicType t) {
                addType(t);
            }

            @Override
            public void visitAggregateTypeImpl(AggregateType t) {
                addType(t);
            }

            @Override
            public void visitTodoTypeImpl(ToDoType t) {
                addType(t);
            }

            @Override
            public void visitCompoundTypeImpl(CompoundType t) {
                stack.push(t.getName());
                t.getFieldTypes().forEach(tt -> {
                    tt.accept(this);
                });
                stack.pop();
            }

            void addType(TagType tt) {
                stack.push(tt.getName());
                typesBySlot.put(C.reverse((List) stack), tt);
                stack.pop();
            }
        });

        // TypesBySlot now contains fully qualified names only. Reverse and store as index.
        typesBySlot.forEach((s, tt) -> fullyQualifiedName.put(tt, s));

        // add abbreviations
        Set<List<String>> ambiguous = new HashSet<>();
        Map<List<String>, TagType> newEntries = new HashMap<>();

        typesBySlot.keySet().forEach(slot -> {
            List<String> cur = C.tail(slot);
            while (!cur.isEmpty()) {
                if (typesBySlot.containsKey(cur) || newEntries.containsKey(cur)) {
                    ambiguous.add(cur);
                    break;
                } else {
                    newEntries.put(cur, typesBySlot.get(slot));
                }
                cur = C.tail(cur);
            }
        });

        ambiguous.forEach(newEntries::remove);
        typesBySlot.putAll(newEntries);
    }

    List<Answer> impliedAnswers( AskNode node ) {
		Set<Answer> answers = node.getAnswers();
		if ( answers.size() > 1 ) return Collections.emptyList();
		if ( answers.isEmpty() ) return Arrays.asList( Answer.NO, Answer.YES ); // special case, where both YES and NO lead to the same options. 
		Answer onlyAns = answers.iterator().next();

        String ansText = onlyAns.getAnswerText().trim().toLowerCase();
		switch( ansText ) {
			case "yes": return Collections.singletonList( Answer.NO );
			case "no" : return Collections.singletonList( Answer.YES );
			default: return Collections.emptyList();	
		}
	}
    
    /**
     * @param aNode the node whose id we want.
     * @return An id for the node (either from the code or generated).
     */
    private String getCreateId(AstNode aNode) {
        return (aNode.getId() == null) ? nextNodeId() : aNode.getId();
    }

    /**
     * Creates a new id, and updates the internal id counter.
     *
     * @return a unique id.
     */
    private String nextNodeId() {
        return "[#" + nextNodeId++ + "]";
    }

    /**
     * Builds a value based on the assignments visited.
     */
    private static class SetNodeValueBuilder implements AstSetNode.Assignment.Visitor {

        private final CompoundValue topValue;

        public SetNodeValueBuilder(CompoundValue topValue) {
            this.topValue = topValue;
        }

        @Override
        public void visit(AstSetNode.AtomicAssignment aa) {
            final CompoundValue additionPoint = descend(aa.getSlot(), topValue);
            TagType valueType = additionPoint.getType().getTypeNamed(C.last(aa.getSlot()));
            if (valueType == null) {
                throw new RuntimeException("Type '" + additionPoint.getType().getName()
                        + "' does not have a field of type '" + C.last(aa.getSlot()));
            }
            valueType.accept(new TagType.VoidVisitor() {
                @Override
                public void visitAtomicTypeImpl(AtomicType t) {
                    AtomicValue value = t.valueOf(aa.getValue());
                    if (value == null) {
                        throw new RuntimeException("Field " + aa.getSlot() + " does not have a value " + aa.getValue());
                    }
                    additionPoint.set(value);
                }

                @Override
                public void visitAggregateTypeImpl(AggregateType t) {
                    throw new RuntimeException("Slot " + aa.getSlot() + " has an aggregate type, not atomic. Use ``+='' .");
                }

                @Override
                public void visitCompoundTypeImpl(CompoundType t) {
                    throw new RuntimeException("Slot " + aa.getSlot() + " is compound, not atomic. Can't assign values here.");
                }

                @Override
                public void visitTodoTypeImpl(ToDoType t) {
                    throw new RuntimeException("Slot " + aa.getSlot() + " is a placeholder. Can't assign values here.");
                }
            });
        }

        @Override
        public void visit(AstSetNode.AggregateAssignment aa) {
            final CompoundValue additionPoint = descend(aa.getSlot(), topValue);
            TagType valueType = additionPoint.getType().getTypeNamed(C.last(aa.getSlot()));
            if (valueType == null) {
                throw new RuntimeException("Type '" + additionPoint.getType().getName()
                        + "' does not have a field of type '" + C.last(aa.getSlot()));
            }
            valueType.accept(new TagType.VoidVisitor() {
                @Override
                public void visitAtomicTypeImpl(AtomicType t) {
                    throw new RuntimeException("Slot " + aa.getSlot() + " has an aggregate type, not atomic. Use ``+='' .");
                }

                @Override
                public void visitAggregateTypeImpl(AggregateType t) {
                    AggregateValue value = (AggregateValue) additionPoint.get(t);
                    if (value == null) {
                        value = t.createInstance();
                        additionPoint.set(value);
                    }
                    for (String val : aa.getValue()) {
                        value.add(t.getItemType().valueOf(val));
                    }
                }

                @Override
                public void visitCompoundTypeImpl(CompoundType t) {
                    throw new RuntimeException("Slot " + aa.getSlot() + " is compound, not atomic. Can't assign values here.");
                }

                @Override
                public void visitTodoTypeImpl(ToDoType t) {
                    throw new RuntimeException("Slot " + aa.getSlot() + " is a placeholder. Can't assign values here.");
                }
            });
        }

        /**
         * Descends the compound value tree, adding values as needed.
         *
         * @param pathRemainder the names of the fields along which we descend.
         * @param cVal the value we start the descend from
         * @return the compound value of the type pointed by the penultimate
         * item in {@code path}
         * @throws RuntimeException if the path is not descendable (i.e fields
         * don't exist or of the wrong type).
         */
        CompoundValue descend(List<String> pathRemainder, CompoundValue cVal) {
            if (pathRemainder.size() == 1) {
                return cVal;
            }
            CompoundType cType = cVal.getType();
            TagType nextTagType = cType.getTypeNamed(C.head(pathRemainder));
            if (nextTagType == null) {
                throw new RuntimeException("Type '" + cType.getName()
                        + "' does not have a field of type '" + C.head(pathRemainder));
            }
            return descend(C.tail(pathRemainder), nextTagType.accept(new TagType.Visitor<CompoundValue>() {
                @Override
                public CompoundValue visitSimpleType(AtomicType t) {
                    throw new RuntimeException("Type '" + t.getName()
                            + "' is not a compound type");
                }

                @Override
                public CompoundValue visitAggregateType(AggregateType t) {
                    throw new RuntimeException("Type '" + t.getName()
                            + "' is not a compound type");
                }

                @Override
                public CompoundValue visitTodoType(ToDoType t) {
                    throw new RuntimeException("Type '" + t.getName() + "' is not a compound type");
                }

                @Override
                public CompoundValue visitCompoundType(CompoundType t) {
                    return t.createInstance();
                }
            }));
        }

    };

}
