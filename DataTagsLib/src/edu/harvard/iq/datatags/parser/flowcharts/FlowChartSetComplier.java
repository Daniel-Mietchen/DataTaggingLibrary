package edu.harvard.iq.datatags.parser.flowcharts;

import edu.harvard.iq.datatags.model.DataTags;
import edu.harvard.iq.datatags.model.charts.FlowChart;
import edu.harvard.iq.datatags.model.charts.FlowChartSet;
import edu.harvard.iq.datatags.model.charts.nodes.AskNode;
import edu.harvard.iq.datatags.model.charts.nodes.CallNode;
import edu.harvard.iq.datatags.model.charts.nodes.EndNode;
import edu.harvard.iq.datatags.model.charts.nodes.Node;
import edu.harvard.iq.datatags.model.charts.nodes.SetNode;
import edu.harvard.iq.datatags.model.charts.nodes.TodoNode;
import static edu.harvard.iq.datatags.model.values.Answer.Answer;
import edu.harvard.iq.datatags.parser.flowcharts.references.AnswerNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.AskNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.CallNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.EndNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.InstructionNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.NodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.SetNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.TermNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.TodoNodeRef;
import static edu.harvard.iq.datatags.util.CollectionHelper.C;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

/**
 * Parser for the chart set graphs.
 * 
 * @author michael
 */
public class FlowChartSetComplier {
	
	private final Map<String, NodeRef> id2NodeRef = new HashMap<>();
	private final Map<String, List<CallNode>> callNodesToLink = new HashMap<>();
	
	public FlowChartSet parse( String source, String unitName ) { 
		return parse( new FlowChartASTParser().graphParser().parse(source), unitName );
	}
	
	public FlowChartSet parse( List<? extends InstructionNodeRef> parsedNodes, String unitName ) { 
		// TODO implement the namespace, use unit name. 
		
		// Map node refs ids to the node refs.
		initIds( parsedNodes );
		
		FlowChartSet chartSet = new FlowChartSet();
		int idx=0;
		for ( List<InstructionNodeRef> nodes : breakList(parsedNodes) ) {
			FlowChart chart = new FlowChart( unitName + "-chart-" + (++idx) );
			Node startNode = buildNodes( nodes, chart );
			chart.setStart(startNode);
			chartSet.addChart(chart);
			if ( chartSet.getDefaultChartId() == null ) { 
				chartSet.setDefaultChartId( chart.getId() );
			}
		}
		
		// TODO validation
		//  - Set nodes has valid slot names and values
		//  - no unreachable nodes (e.g. chart with no id at start node)
		
		return chartSet;
	}
	
	/**
	 * Break a list of instruction nodes to reachable components. 
	 * The list generated by the AST parser contains connections that do not make semantic
	 * sense - namely, EndNodeRef's next pointer. We break the list on those 
	 * @param parsed
	 * @return 
	 */
	List<List<InstructionNodeRef>> breakList( List<? extends InstructionNodeRef> parsed ) {
		List<List<InstructionNodeRef>> res = new LinkedList<>();
		List<InstructionNodeRef> cur = new LinkedList<>();
		
		for ( InstructionNodeRef inr : parsed ) {
			cur.add( inr );
			if ( inr instanceof EndNodeRef ) {
				res.add( cur );
				cur = new LinkedList<>();
			}
		}
		res.add( cur );
		
		return res;
	}
	
	private Node buildNodes( final List<? extends InstructionNodeRef> nodes, final FlowChart chart ) {
		
		InstructionNodeRef.Visitor<Node> builder = new InstructionNodeRef.Visitor<Node>(){
			@Override
			public Node visit(AskNodeRef askRef) {
				AskNode res = new AskNode( askRef.getId() );
				
				res.setText( askRef.getTextNode().getText() );
				for ( TermNodeRef termRef : askRef.getTerms() ) {
					res.addTerm(termRef.getTerm(), termRef.getExplanation() );
				}
				
				for ( AnswerNodeRef ansRef : askRef.getAnswers() ) {
					res.setNodeFor( Answer(ansRef.getAnswerText()), 
								    buildNodes(ansRef.getImplementation(), chart)
								  );
				}
				// FIXME connect the open ends to the syntacticly next node (?) 
				return chart.add( res );
			}

			@Override
			public Node visit(CallNodeRef callRef) {
				CallNode res = new CallNode( callRef.getId() );
				res.setCalleeChartId( chart.getId() );
				res.setCalleeNodeId( callRef.getCalleeId() );
				if ( ! callNodesToLink.containsKey(res.getCalleeNodeId()) ) {
					callNodesToLink.put( res.getCalleeNodeId(), new LinkedList<CallNode>() );
				}
				callNodesToLink.get(res.getCalleeNodeId()).add( res );
				res.setNextNode( buildNodes(C.tail(nodes), chart) );
				return chart.add( res );
			}

			@Override
			public Node visit(EndNodeRef endRef) {
				return endRef.getId().startsWith("$") // LATER should be "isAuto", when id is a full object
						? chart.getEndNode()
						: new EndNode( endRef.getId() );
			}	

			@Override
			public Node visit(SetNodeRef setRef) {
				SetNode res = new SetNode( buildDataTags(setRef), setRef.getId() );
				res.setNextNode(buildNodes( C.tail(nodes), chart));
				return chart.add( res );
			}

			@Override
			public Node visit(TodoNodeRef todoRef) {
				TodoNode res = new TodoNode( todoRef.getId() );
				res.setTodoText(todoRef.getTodoText() );
				res.setNextNode( buildNodes( C.tail(nodes), chart) );
				return chart.add(res);
			}
		};
		
		return nodes.isEmpty() 
				? chart.getEndNode()
				: C.head( nodes ).accept(builder);
	}
	
	DataTags buildDataTags( SetNodeRef nodeRef ) {
		// TODO implement buildDataTags
		return new DataTags();
	}
	
	
	/**
	 * Inits all the ids of the nodes in the list. Also, collects the 
	 * user-assigned ids in {@link #id2NodeRef}.
	 * @param nodeRefs 
	 */
	protected void initIds( List<? extends InstructionNodeRef> nodeRefs ) {
		final InstructionNodeRef.Visitor<Void> visitor = new InstructionNodeRef.Visitor<Void>() {
			
			private int nextId=0;
			
			@Override
			public Void visit(AskNodeRef askRef) {
				visitSimpleNode( askRef );
				visitSimpleNode( askRef.getTextNode() );
				for ( TermNodeRef tnd:askRef.getTerms() ) {
					visitSimpleNode(tnd);
				}
				
				for ( AnswerNodeRef ans : askRef.getAnswers() ) {
					visitSimpleNode(ans);
					for ( InstructionNodeRef inr : ans.getImplementation() ) {
						inr.accept(this);
					}
				}
				
				return null;
			}

			@Override
			public Void visit(CallNodeRef callRef) {
				return visitSimpleNode(callRef);
			}

			@Override
			public Void visit(EndNodeRef nedRef) {
				return visitSimpleNode(nedRef);
			}

			@Override
			public Void visit(SetNodeRef setRef) {
				return visitSimpleNode(setRef);
			}

			@Override
			public Void visit(TodoNodeRef todoRef) {
				return visitSimpleNode(todoRef);
			}
			
			private Void visitSimpleNode( NodeRef simpleNodeRef ) {
				if ( simpleNodeRef.getId() == null ) {
					simpleNodeRef.setId(nextId());
				} else {
					id2NodeRef.put(simpleNodeRef.getId(), simpleNodeRef);
				}
				return null;
			}
			
			private String nextId() {
				return "$"+(nextId++);
			}
		};
		
		for ( InstructionNodeRef inr: nodeRefs ) {
			inr.accept(visitor);
		}
	}
}
