package edu.harvard.iq.datatags.parser.flowcharts;

import edu.harvard.iq.datatags.model.DataTags;
import edu.harvard.iq.datatags.model.charts.FlowChart;
import edu.harvard.iq.datatags.model.charts.FlowChartSet;
import edu.harvard.iq.datatags.model.charts.nodes.AskNode;
import edu.harvard.iq.datatags.model.charts.nodes.CallNode;
import edu.harvard.iq.datatags.model.charts.nodes.EndNode;
import edu.harvard.iq.datatags.model.charts.nodes.Node;
import edu.harvard.iq.datatags.model.charts.nodes.SetNode;
import edu.harvard.iq.datatags.model.charts.nodes.TodoNode;
import edu.harvard.iq.datatags.model.types.AggregateType;
import edu.harvard.iq.datatags.model.types.CompoundType;
import edu.harvard.iq.datatags.model.types.SimpleType;
import edu.harvard.iq.datatags.model.types.TagType;
import edu.harvard.iq.datatags.model.types.ToDoType;
import edu.harvard.iq.datatags.model.values.AggregateValue;
import edu.harvard.iq.datatags.model.values.Answer;
import static edu.harvard.iq.datatags.model.values.Answer.Answer;
import edu.harvard.iq.datatags.model.values.SimpleValue;
import edu.harvard.iq.datatags.model.values.TagValue;
import edu.harvard.iq.datatags.parser.exceptions.BadSetInstructionException;
import edu.harvard.iq.datatags.parser.flowcharts.references.AnswerNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.AskNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.CallNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.EndNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.InstructionNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.NodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.SetNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.TermNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.TodoNodeRef;
import static edu.harvard.iq.datatags.util.CollectionHelper.C;
import java.util.Arrays;
import java.util.Collections;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Parser for the chart set graphs.
 * 
 * @author michael
 */
public class FlowChartSetComplier {
	
	private final Map<String, NodeRef> id2NodeRef = new HashMap<>();
	private final Map<String, List<CallNode>> callNodesToLink = new HashMap<>();
	
    /**
     * The base type of the data tags (typically, "DataTags").
     * While constructing {@link SetNode}s, this type is used to build node's
     * {@link DataTags} object.
     */
    private final TagType baseType;
    
    
    public FlowChartSetComplier(TagType baseType) {
        this.baseType = baseType;
    }
    
    
	public FlowChartSet parse( String source, String unitName ) throws BadSetInstructionException { 
		return parse( new FlowChartASTParser().graphParser().parse(source), unitName );
	}
	
	public FlowChartSet parse( List<? extends InstructionNodeRef> parsedNodes, String unitName ) throws BadSetInstructionException { 
		// TODO implement the namespace, use unit name. 
		
		// Map node refs ids to the node refs.
		initIds( parsedNodes );
		
		FlowChartSet chartSet = new FlowChartSet();
		FlowChart chart = new FlowChart( unitName + "-c1" );
		chartSet.addChart(chart);
		chartSet.setDefaultChartId( chart.getId() );
        try {
            for ( List<InstructionNodeRef> nodes : breakList(parsedNodes) ) {
                Node startNode = buildNodes( nodes, chart, chart.getEndNode() );
                if ( chart.getStart()== null ) { 
                    chart.setStart(startNode);
                }
            }
        } catch ( RuntimeException rte ) {
            Throwable cause = rte.getCause();
            if ( cause != null && cause instanceof BadSetInstructionException ) {
                throw (BadSetInstructionException)cause;
            } else { 
                throw rte;
            }
        }
		
		// TODO validation
		//  - Ids get to appear at most once. 
		//  - Set nodes has valid slot names and values
		//  - no unreachable nodes (e.g. chart with no id at start node)
		
		return chartSet;
	}
	
	/**
	 * Break a list of instruction nodes to reachable components. 
	 * The list generated by the AST parser contains connections that do not make semantic
	 * sense - namely, EndNodeRef's next pointer. We break the list on those 
	 * @param parsed
	 * @return 
	 */
	List<List<InstructionNodeRef>> breakList( List<? extends InstructionNodeRef> parsed ) {
		List<List<InstructionNodeRef>> res = new LinkedList<>();
		List<InstructionNodeRef> cur = new LinkedList<>();
		
		for ( InstructionNodeRef node : parsed ) {
			cur.add( node );
			if ( node instanceof EndNodeRef ) {
				res.add( cur );
				cur = new LinkedList<>();
			}
		}
		res.add( cur );
		
		return res;
	}
	
	/**
	 * Builds nodes from parsed node references
	 * @param nodes the parsed node reference list,
	 * @param chart The chart being built (nodes are added to it)
	 * @param defaultNode the node to go to when the chart ends. In effect, when a 
	 *		              strand of nodes ends in a non-terminating reference, this node
	 *					  is returned.
	 * @return the node at the root of the execution path.
	 */
	private Node buildNodes( final List<? extends InstructionNodeRef> nodes, final FlowChart chart, final Node defaultNode ) {
		
		InstructionNodeRef.Visitor<Node> builder = new InstructionNodeRef.Visitor<Node>(){
			@Override
			public Node visit(AskNodeRef askRef) {
				AskNode res = new AskNode( askRef.getId() );
				
				res.setText( askRef.getTextNode().getText() );
				for ( TermNodeRef termRef : askRef.getTerms() ) {
					res.addTerm(termRef.getTerm(), termRef.getExplanation() );
				}
				
				Node syntacticallyNext = buildNodes(C.tail(nodes), chart, defaultNode );
				
				for ( AnswerNodeRef ansRef : askRef.getAnswers() ) {
					res.setNodeFor( Answer(ansRef.getAnswerText()), 
								    buildNodes(ansRef.getImplementation(), chart, syntacticallyNext)
								  );
				}
				
				// if the question is implied binary, we add implied answers.
				for ( Answer ans : impliedAnswers(res) ) {
					res.setNodeFor(ans, syntacticallyNext);
				} 
				
				return chart.add( res );
			}

			@Override
			public Node visit(CallNodeRef callRef) {
				CallNode res = new CallNode( callRef.getId() );
				res.setCalleeChartId( chart.getId() );
				res.setCalleeNodeId( callRef.getCalleeId() );
				if ( ! callNodesToLink.containsKey(res.getCalleeNodeId()) ) {
					callNodesToLink.put( res.getCalleeNodeId(), new LinkedList<CallNode>() );
				}
				callNodesToLink.get(res.getCalleeNodeId()).add( res );
				res.setNextNode( buildNodes(C.tail(nodes), chart, defaultNode) );
				return chart.add( res );
			}

			@Override
			public Node visit(EndNodeRef endRef) {
				return endRef.getId().startsWith("$") // LATER should be "isAuto", when id is a full object
						? chart.getEndNode()
						: new EndNode( endRef.getId() );
			}	

			@Override
			public Node visit(SetNodeRef setRef) {
                try {
                    SetNode res = new SetNode( buildDataTags(setRef), setRef.getId() );
                    res.setNextNode(buildNodes( C.tail(nodes), chart, defaultNode));
                    return chart.add( res );
                } catch (BadSetInstructionException ex) {
                    throw new RuntimeException("Bad Set", ex );
                }
			}

			@Override
			public Node visit(TodoNodeRef todoRef) {
				TodoNode res = new TodoNode( todoRef.getId() );
				res.setTodoText(todoRef.getTodoText() );
				res.setNextNode( buildNodes( C.tail(nodes), chart, defaultNode) );
				return chart.add(res);
			}
		};
		
		return nodes.isEmpty() ? defaultNode : C.head( nodes ).accept(builder);
	}
	
	DataTags buildDataTags( SetNodeRef nodeRef ) throws BadSetInstructionException {
        DataTags res = new DataTags();
		for ( String slotName : nodeRef.getSlotNames() ) {
            SetLookupResult slr = getTagValueFor( slotName, nodeRef.getValue(slotName));
            if ( slr.status == SetLookupResult.Status.Success ) {
                res.set(slr.get());
            } else {
                throw new BadSetInstructionException(slr, nodeRef);
            }
        }
		return res;
	}
	
	List<Answer> impliedAnswers( AskNode node ) {
		Set<Answer> answers = node.getAnswers();
		if ( answers.size() > 1 ) return Collections.emptyList();
		if ( answers.isEmpty() ) return Arrays.asList( Answer.NO, Answer.YES ); // special case, where both YES and NO lead to the same options. 
		// MAYBE issue a warning/suggestion to make this a (todo: ) node.
		
		Answer onlyAns = answers.iterator().next();
		String ansText = onlyAns.getAnswerText().trim().toLowerCase();
		switch( ansText ) {
			case "yes": return Collections.singletonList( Answer.NO );
			case "no" : return Collections.singletonList( Answer.YES );
			default: return Collections.emptyList();	
		}
	}
	
     SetLookupResult getTagValueFor( final String slotName, final String valueName ) {
        return baseType.accept(new TagType.Visitor<SetLookupResult>() {

            @Override
            public SetLookupResult visitSimpleType(SimpleType t) {
                if ( slotName.equals(t.getName())) {
                    TagValue v = t.valueOf( valueName );
                    return (v!=null) ? SetLookupResult.Success(v)
                                     : SetLookupResult.ValueNotFound(t, valueName);
                } else {
                    return SetLookupResult.SlotNotFound(slotName);
                }
            }

            @Override
            public SetLookupResult visitAggregateType(AggregateType t) {
                if ( slotName.equals(t.getName())) {
                    AggregateValue res = t.make();
                    SimpleValue singleValue = t.getItemType().valueOf(valueName);
                    
                    if ( singleValue == null ) {
                        return SetLookupResult.ValueNotFound(baseType, valueName);
                    } else {
                        res.add(singleValue);
                        return SetLookupResult.Success(res);
                    }
                    
                } else {
                    return SetLookupResult.SlotNotFound(slotName);
                }
            }

            @Override
            public SetLookupResult visitCompoundType(CompoundType t) {
                Map<SetLookupResult.Status, Set<SetLookupResult>> results = new EnumMap<>(SetLookupResult.Status.class);
                for ( SetLookupResult.Status s : SetLookupResult.Status.values() ) {
                    results.put( s, new HashSet<SetLookupResult>() );
                }
                
                // group results by status.
                for ( TagType tt : t.getFieldTypes() ) {
                    SetLookupResult res = tt.accept(this);
                    results.get(res.status).add(res);
                }
                
                if ( ! results.get(SetLookupResult.Status.Success).isEmpty() ) {
                    Set<SetLookupResult> founds = results.get(SetLookupResult.Status.Success);
                    return ( founds.size() == 1 ) 
                             ? founds.iterator().next()
                             : SetLookupResult.Ambiguous(founds);
                }
                
                if ( ! results.get(SetLookupResult.Status.Ambiguous).isEmpty() ) {
                    return SetLookupResult.Ambiguous( results.get(SetLookupResult.Status.Ambiguous) );
                }

                if ( ! results.get(SetLookupResult.Status.ValueNotFound).isEmpty() ) {
                    return results.get(SetLookupResult.Status.ValueNotFound).iterator().next();
                }

                return SetLookupResult.SlotNotFound(slotName);
                
            }

            @Override
            public SetLookupResult visitTodoType(ToDoType t) {
                if ( slotName.equals(t.getName())) {
                    return SetLookupResult.Success(t.getValue());
                } else {
                    return SetLookupResult.SlotNotFound(slotName);
                }
            }
        });
    }
    
	/**
	 * Inits all the ids of the nodes in the list. Also, collects the 
	 * user-assigned ids in {@link #id2NodeRef}.
	 * @param nodeRefs 
	 */
	protected void initIds( List<? extends InstructionNodeRef> nodeRefs ) {
		final InstructionNodeRef.Visitor<Void> visitor = new InstructionNodeRef.Visitor<Void>() {
			
			private int nextId=0;
			
			@Override
			public Void visit(AskNodeRef askRef) {
				visitSimpleNode( askRef );
				visitSimpleNode( askRef.getTextNode() );
				for ( TermNodeRef tnd:askRef.getTerms() ) {
					visitSimpleNode(tnd);
				}
				
				for ( AnswerNodeRef ans : askRef.getAnswers() ) {
					visitSimpleNode(ans);
					for ( InstructionNodeRef inr : ans.getImplementation() ) {
						inr.accept(this);
					}
				}
				
				return null;
			}

			@Override
			public Void visit(CallNodeRef callRef) {
				return visitSimpleNode(callRef);
			}

			@Override
			public Void visit(EndNodeRef nedRef) {
				return visitSimpleNode(nedRef);
			}

			@Override
			public Void visit(SetNodeRef setRef) {
				return visitSimpleNode(setRef);
			}

			@Override
			public Void visit(TodoNodeRef todoRef) {
				return visitSimpleNode(todoRef);
			}
			
			private Void visitSimpleNode( NodeRef simpleNodeRef ) {
				if ( simpleNodeRef.getId() == null ) {
					simpleNodeRef.setId(nextId());
				} else {
					id2NodeRef.put(simpleNodeRef.getId(), simpleNodeRef);
				}
				return null;
			}
			
			private String nextId() {
				return "$"+(nextId++);
			}
		};
		
		for ( InstructionNodeRef inr: nodeRefs ) {
			inr.accept(visitor);
		}
	}

}
