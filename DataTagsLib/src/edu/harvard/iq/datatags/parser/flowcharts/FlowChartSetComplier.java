package edu.harvard.iq.datatags.parser.flowcharts;

import edu.harvard.iq.datatags.model.DataTags;
import edu.harvard.iq.datatags.model.charts.FlowChart;
import edu.harvard.iq.datatags.model.charts.FlowChartSet;
import edu.harvard.iq.datatags.model.charts.nodes.AskNode;
import edu.harvard.iq.datatags.model.charts.nodes.CallNode;
import edu.harvard.iq.datatags.model.charts.nodes.EndNode;
import edu.harvard.iq.datatags.model.charts.nodes.Node;
import edu.harvard.iq.datatags.model.charts.nodes.SetNode;
import edu.harvard.iq.datatags.model.charts.nodes.ThroughNode;
import edu.harvard.iq.datatags.model.charts.nodes.TodoNode;
import edu.harvard.iq.datatags.model.values.Answer;
import static edu.harvard.iq.datatags.model.values.Answer.Answer;
import edu.harvard.iq.datatags.parser.flowcharts.references.AnswerNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.AskNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.CallNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.EndNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.InstructionNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.NodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.SetNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.TermNodeRef;
import edu.harvard.iq.datatags.parser.flowcharts.references.TodoNodeRef;
import edu.harvard.iq.datatags.runtime.exceptions.DataTagsRuntimeException;
import static edu.harvard.iq.datatags.util.CollectionHelper.C;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Parser for the chart set graphs.
 * 
 * @author michael
 */
public class FlowChartSetComplier {
	
	private final Map<String, NodeRef> id2NodeRef = new HashMap<>();
	private final Map<String, List<CallNode>> callNodesToLink = new HashMap<>();
	
	public FlowChartSet parse( String source, String unitName ) { 
		return parse( new FlowChartASTParser().graphParser().parse(source), unitName );
	}
	
	public FlowChartSet parse( List<? extends InstructionNodeRef> parsedNodes, String unitName ) { 
		// TODO implement the namespace, use unit name. 
		
		// Map node refs ids to the node refs.
		initIds( parsedNodes );
		
		FlowChartSet chartSet = new FlowChartSet();
		FlowChart chart = new FlowChart( unitName + "-c1" );
		chartSet.addChart(chart);
		chartSet.setDefaultChartId( chart.getId() );
		for ( List<InstructionNodeRef> nodes : breakList(parsedNodes) ) {
			Node startNode = buildNodes( nodes, chart, chart.getEndNode() );
			if ( chart.getStart()== null ) { 
				chart.setStart(startNode);
			}
//			startNode.accept( new OpenEndsConnector(chart.getEndNode()) );
		}
		
		// TODO validation
		//  - Ids get to appear at most once. 
		//  - Set nodes has valid slot names and values
		//  - no unreachable nodes (e.g. chart with no id at start node)
		
		return chartSet;
	}
	
	/**
	 * Break a list of instruction nodes to reachable components. 
	 * The list generated by the AST parser contains connections that do not make semantic
	 * sense - namely, EndNodeRef's next pointer. We break the list on those 
	 * @param parsed
	 * @return 
	 */
	List<List<InstructionNodeRef>> breakList( List<? extends InstructionNodeRef> parsed ) {
		List<List<InstructionNodeRef>> res = new LinkedList<>();
		List<InstructionNodeRef> cur = new LinkedList<>();
		
		for ( InstructionNodeRef node : parsed ) {
			cur.add( node );
			if ( node instanceof EndNodeRef ) {
				res.add( cur );
				cur = new LinkedList<>();
			}
		}
		res.add( cur );
		
		return res;
	}
	
	/**
	 * Builds nodes from parsed node references
	 * @param nodes the parsed node reference list,
	 * @param chart The chart being built (nodes are added to it)
	 * @return the node at the root of the execution path.
	 */
	private Node buildNodes( final List<? extends InstructionNodeRef> nodes, final FlowChart chart, final Node defaultNode ) {
		
		InstructionNodeRef.Visitor<Node> builder = new InstructionNodeRef.Visitor<Node>(){
			@Override
			public Node visit(AskNodeRef askRef) {
				AskNode res = new AskNode( askRef.getId() );
				
				res.setText( askRef.getTextNode().getText() );
				for ( TermNodeRef termRef : askRef.getTerms() ) {
					res.addTerm(termRef.getTerm(), termRef.getExplanation() );
				}
				
				Node syntacticallyNext = buildNodes(C.tail(nodes), chart, defaultNode );
				
				for ( AnswerNodeRef ansRef : askRef.getAnswers() ) {
					res.setNodeFor( Answer(ansRef.getAnswerText()), 
								    buildNodes(ansRef.getImplementation(), chart, syntacticallyNext)
								  );
				}
				
				// Connect any open ends to the next node.
//				res.accept( new OpenEndsConnector(syntacticallyNext));
				
				// if the question is implied binary, we add implied answers.
				for ( Answer ans : impliedAnswers(res) ) {
					res.setNodeFor(ans, syntacticallyNext);
				} 
				
				return chart.add( res );
			}

			@Override
			public Node visit(CallNodeRef callRef) {
				CallNode res = new CallNode( callRef.getId() );
				res.setCalleeChartId( chart.getId() );
				res.setCalleeNodeId( callRef.getCalleeId() );
				if ( ! callNodesToLink.containsKey(res.getCalleeNodeId()) ) {
					callNodesToLink.put( res.getCalleeNodeId(), new LinkedList<CallNode>() );
				}
				callNodesToLink.get(res.getCalleeNodeId()).add( res );
				res.setNextNode( buildNodes(C.tail(nodes), chart, defaultNode) );
				return chart.add( res );
			}

			@Override
			public Node visit(EndNodeRef endRef) {
				return endRef.getId().startsWith("$") // LATER should be "isAuto", when id is a full object
						? chart.getEndNode()
						: new EndNode( endRef.getId() );
			}	

			@Override
			public Node visit(SetNodeRef setRef) {
				SetNode res = new SetNode( buildDataTags(setRef), setRef.getId() );
				res.setNextNode(buildNodes( C.tail(nodes), chart, defaultNode));
				return chart.add( res );
			}

			@Override
			public Node visit(TodoNodeRef todoRef) {
				TodoNode res = new TodoNode( todoRef.getId() );
				res.setTodoText(todoRef.getTodoText() );
				res.setNextNode( buildNodes( C.tail(nodes), chart, defaultNode) );
				return chart.add(res);
			}
		};
		
		return nodes.isEmpty() ? defaultNode : C.head( nodes ).accept(builder);
	}
	
	DataTags buildDataTags( SetNodeRef nodeRef ) {
		// TODO implement buildDataTags
		return new DataTags();
	}
	
	List<Answer> impliedAnswers( AskNode node ) {
		Set<Answer> answers = node.getAnswers();
		if ( answers.size() > 1 ) return Collections.emptyList();
		if ( answers.isEmpty() ) return Arrays.asList( Answer.NO, Answer.YES ); // special case, where both YES and NO lead to the same options. 
		// MAYBE issue a warning/suggestion to make this a (todo: ) node.
		
		Answer onlyAns = answers.iterator().next();
		String ansText = onlyAns.getAnswerText().trim().toLowerCase();
		switch( ansText ) {
			case "yes": return Collections.singletonList( Answer.NO );
			case "no" : return Collections.singletonList( Answer.YES );
			default: return Collections.emptyList();	
		}
	}
	
	/**
	 * Inits all the ids of the nodes in the list. Also, collects the 
	 * user-assigned ids in {@link #id2NodeRef}.
	 * @param nodeRefs 
	 */
	protected void initIds( List<? extends InstructionNodeRef> nodeRefs ) {
		final InstructionNodeRef.Visitor<Void> visitor = new InstructionNodeRef.Visitor<Void>() {
			
			private int nextId=0;
			
			@Override
			public Void visit(AskNodeRef askRef) {
				visitSimpleNode( askRef );
				visitSimpleNode( askRef.getTextNode() );
				for ( TermNodeRef tnd:askRef.getTerms() ) {
					visitSimpleNode(tnd);
				}
				
				for ( AnswerNodeRef ans : askRef.getAnswers() ) {
					visitSimpleNode(ans);
					for ( InstructionNodeRef inr : ans.getImplementation() ) {
						inr.accept(this);
					}
				}
				
				return null;
			}

			@Override
			public Void visit(CallNodeRef callRef) {
				return visitSimpleNode(callRef);
			}

			@Override
			public Void visit(EndNodeRef nedRef) {
				return visitSimpleNode(nedRef);
			}

			@Override
			public Void visit(SetNodeRef setRef) {
				return visitSimpleNode(setRef);
			}

			@Override
			public Void visit(TodoNodeRef todoRef) {
				return visitSimpleNode(todoRef);
			}
			
			private Void visitSimpleNode( NodeRef simpleNodeRef ) {
				if ( simpleNodeRef.getId() == null ) {
					simpleNodeRef.setId(nextId());
				} else {
					id2NodeRef.put(simpleNodeRef.getId(), simpleNodeRef);
				}
				return null;
			}
			
			private String nextId() {
				return "$"+(nextId++);
			}
		};
		
		for ( InstructionNodeRef inr: nodeRefs ) {
			inr.accept(visitor);
		}
	}
	
	/**
	 * Descends on a Node tree, and connects all open ends to the passed
	 * connector.
	 */
	private class OpenEndsConnector implements Node.Visitor<Void> {
		
		final Node nextNode;

		public OpenEndsConnector(Node nextNode) {
			this.nextNode = nextNode;
		}
		
		@Override
		public Void visitAskNode(AskNode nd) throws DataTagsRuntimeException {
			for ( Answer ans : nd.getAnswers() ) {
				nd.getNodeFor(ans).accept( this );
			}
			return null;
		}

		@Override
		public Void visitSetNode(SetNode nd) throws DataTagsRuntimeException {
			return visitThroughNode(nd);
		}

		@Override
		public Void visitCallNode(CallNode nd) throws DataTagsRuntimeException {
			return visitThroughNode(nd);
		}

		@Override
		public Void visitTodoNode(TodoNode nd) throws DataTagsRuntimeException {
			return visitThroughNode(nd);
		}

		@Override
		public Void visitEndNode(EndNode nd) throws DataTagsRuntimeException {
			// do nothing, we've reached a terminating node.
			return null;
		}
		
		private Void visitThroughNode( ThroughNode nd ) {
			if ( nd.getNextNode() == null ) {
				// Ah! got to an open end. This is what we live for.
				nd.setNextNode( nextNode );
			} else {
				nd.getNextNode().accept( this );
			}
			return null;
		}
	}
}
